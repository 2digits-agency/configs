import type { Format, TransformedToken } from 'style-dictionary/types';

type TokenValue = string | Array<string> | [string, { lineHeight: string }];

interface TokenGroup {
  [key: string]: TokenValue | TokenGroup;
}

/**
 * Generates a Tailwind CSS config file from design tokens.
 */
export const tailwindConfigFormat: Format = {
  name: 'tailwind/config',
  format({ dictionary }) {
    const colors = buildColors(dictionary.allTokens);
    const spacing = buildSpacing(dictionary.allTokens);
    const borderRadius = buildBorderRadius(dictionary.allTokens);
    const fontFamily = buildFontFamily(dictionary.allTokens);
    const fontSize = buildFontSize(dictionary.allTokens);

    const config = {
      theme: {
        colors,
        spacing,
        borderRadius,
        fontFamily,
        fontSize,
      },
    };

    return `// Generated by @2digits/design-tokens - do not edit manually
import type { Config } from 'tailwindcss';

export default ${JSON.stringify(config, undefined, 2)} satisfies Partial<Config>;
`;
  },
};

function normalizeGroupName(group: string): string {
  const parts = group.split(/\s*[-â€“]\s*/);
  const name = parts.at(-1) ?? group;

  return kebabCase(name);
}

function buildColorKey(path: Array<string>): { container: string; key: string } {
  const [group, ...rest] = path;
  const container = normalizeGroupName(group ?? '');
  const key = rest.map((p) => kebabCase(p)).join('-');

  return { container, key };
}

function buildColors(tokens: Array<TransformedToken>): TokenGroup {
  const colors: TokenGroup = {};

  for (const token of tokens) {
    if (token.$type !== 'color' || typeof token.$value !== 'string') {
      continue;
    }

    if (token.path.length < 2) {
      continue;
    }

    const { container, key } = buildColorKey(token.path);

    if (!container || !key) {
      continue;
    }

    colors[container] = colors[container] ?? {};
    (colors[container] as TokenGroup)[key] = token.$value;
  }

  return colors;
}

function buildSpacing(tokens: Array<TransformedToken>): TokenGroup {
  const spacing: TokenGroup = {};

  for (const token of tokens) {
    if (token.$type !== 'number') {
      continue;
    }
    const path = token.path;

    if (path.length < 2) {
      continue;
    }

    const [group, subKey] = path;

    if (group === undefined || subKey === undefined) {
      continue;
    }

    if (group === 'Gaps padding and margins') {
      const key = subKey.replace('spacing-', '');

      spacing[key] = String(token.$value);
    } else if (group === 'Container') {
      const key = kebabCase(subKey);

      spacing[key] = String(token.$value);
    }
  }

  return spacing;
}

function buildBorderRadius(tokens: Array<TransformedToken>): TokenGroup {
  const radius: TokenGroup = {};

  for (const token of tokens) {
    if (token.$type !== 'number') {
      continue;
    }
    const path = token.path;

    if (path.length !== 2) {
      continue;
    }

    const [group, subKey] = path;

    if (group === undefined || subKey === undefined) {
      continue;
    }

    if (group === 'Radius') {
      const key = subKey.replace('radius-', '');
      const px = token.$value as number;

      radius[key] = px === 9999 ? '9999px' : `${px}px`;
    }
  }

  return radius;
}

function buildFontFamily(tokens: Array<TransformedToken>): TokenGroup {
  const families: TokenGroup = {};

  for (const token of tokens) {
    if (token.$type !== 'string') {
      continue;
    }
    const path = token.path;

    if (path.length < 3) {
      continue;
    }

    const [group, subGroup, name] = path;

    if (group === undefined || subGroup === undefined || name === undefined) {
      continue;
    }

    if (group === 'Typography' && subGroup === 'Font Family') {
      const key = name.toLowerCase();
      const value = token.$value as string;

      // Add fallback fonts
      families[key] = key === 'icons' ? [value] : [value, 'sans-serif'];
    }
  }

  return families;
}

interface FontSizeData {
  size: number;
  lineHeight: number;
}

function isTypographyToken(group: string, category: string): boolean {
  return group === 'Typography' && (category === 'Headings' || category === 'Paragraph');
}

function updateSizeData(sizeData: Record<string, FontSizeData>, name: string, property: string, value: number): void {
  sizeData[name] = sizeData[name] ?? { size: 16, lineHeight: 24 };

  if (property === 'Font size') {
    sizeData[name].size = value;
  } else if (property === 'Line Height') {
    sizeData[name].lineHeight = value;
  }
}

function convertSizeDataToTokenGroup(sizeData: Record<string, FontSizeData>): TokenGroup {
  const sizes: TokenGroup = {};

  for (const [key, data] of Object.entries(sizeData)) {
    const sizeRem = data.size / 16;
    const lineHeightRatio = data.lineHeight / data.size;

    sizes[key.toLowerCase()] = [`${sizeRem}rem`, { lineHeight: lineHeightRatio.toFixed(3) }];
  }

  return sizes;
}

function buildFontSize(tokens: Array<TransformedToken>): TokenGroup {
  const sizeData: Record<string, FontSizeData> = {};

  for (const token of tokens) {
    if (token.$type !== 'number' || token.path.length < 4) {
      continue;
    }

    const [group, category, name, property] = token.path;

    if (group === undefined || category === undefined || name === undefined || property === undefined) {
      continue;
    }

    if (isTypographyToken(group, category)) {
      updateSizeData(sizeData, name, property, token.$value as number);
    }
  }

  return convertSizeDataToTokenGroup(sizeData);
}

function kebabCase(str: string): string {
  return str
    .replaceAll(/([a-z])([A-Z])/g, '$1-$2')
    .replaceAll(/[\s_]+/g, '-')
    .toLowerCase();
}
